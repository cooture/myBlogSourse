---
title: 数字电路第六章：同步时序逻辑电路——上（状态编码之前）
date: 2018-01-06 00:55:39
tags:
	- 笔记
	- 数字电路
categories: 数字电路
---
# 数字电路第六章：同步时序逻辑电路——上（状态编码之前）
> 讲同步时序逻辑电路的工作原理、分析方法和设计方法。  
> 逻辑电路分为：组合逻辑电路和时序逻辑电路。  
> 组合逻辑电路是指典礼在任何时刻所产生的输出仅取决于该时刻电路的输入。  
> 时序逻辑电路按其工作方式不同分为：同步时序逻辑电路、异步时序逻辑电路。  
> 本章介绍同步时序逻辑电路的分析与设计。    

## 同步时序逻辑电路的模型和描述方法
### 同步时序逻辑电路的结构模型
同步时序逻辑电路是一种与时序有关的电路，一般说来，是由组合电路和存储电路两部分组成，并形成反馈电路。  
![](a.png)  
**组合逻辑电路的输出**  
1. 向外输出 Z   
2. 内部输出 Q 

**组合逻辑电路的输入**  
1. 外部输入：整个时序电路的输入 X  
2. 内部输入：存储电路的内部输出 Y  

**函数的意义**  
Zi称为输出函数  
Yj称为驱动方程  
Mealy型电路：Z的输出既和存储电路的输出有关有和当前状态的输入x有关。  
Moore型电路：Z的输出只和存储电路的输出有关。  
**采用时钟控制的触发器构成存储电路**  
存储时序电路中的二进制信息被定义为电路的状态，触发器的状态就称为时序电路的状态。  
**向量函数**  
![](b.png)
时钟信号不能间隔过短，要状态状态稳定后再一个信号再来。  
### 同步时序逻辑电路的描述方法
为了形象的表示时序逻辑电路的全过程性，把电路在一系列的时钟信号作用下状态转换的全过程找出来，则电路的逻辑功能就一目了然了。  
描述时序电路状态的转换全部过程的方法：  
1. 状态方程  
2. 状态转换表（状态转换真值表）  
3. 状态转换图（简称状态图）  
4. 时序图（波形图）  

#### 状态方程

输出方程：表示输出与输入和现态的关系  
驱动方程：表示现态向次态转换所需的条件  
状态方程：表示在给定的输入下将使现态转向状态  
#### 状态转换表
由现态Q、次态Qn+1和输出Z组成。  
例：  
![](c.png)  
![](d.png)  
![](e.png)

#### 状态转换图
在状态转换图中以圆圈表示电路的各个状态，以箭头表示状态转换的方向。 同时，还在箭头旁注明了状态转换前的输入变量取 值和输出值。通常将输入变量取值写在斜线以上，将输出值写在斜线以下。
![](f.png)  
#### 时序图
将状态转换表的内容画成时间波形图。在时钟脉冲序列作用下，电路状态、输出状态随时间变化的波形图叫做时序图。而且便于用实验观察的方法检查时序电路的逻辑功能。
![](g.png)

## 同步时序逻辑电路的分析方法
根据给定的逻辑电路图，找出他的状态方程、输出方程、状态图和时序图。用这些方法来描述电路的工作全过程及输入输出关系。
### 时序逻辑电路的分析步骤
找出给定时序电路的逻辑功能即找出在输入信号和时钟信号作用下，电路的次态和输出。一般步骤如下：  
1. 根据给定的逻辑电路图，写出每个触发器的驱动方程（控制方程）。  
2. 把得到的驱动方程带入相应的触发器的特性方程，得出每个触发器的状态方程，从而写出这些状态方程的方程组。并写出输出方程。  
3. 建立状态转换真值表  
4. 做出状态图和时序波形图。  
5. 总结功能。  

### 同步时序电路分析的例子
![](h.png)  
![](i.png)
![](j.png)  
![](k.png)
1. 找每个触发器的输入端，写方程，=1的框框是环和。  
2. 把写好的方程带入触发器的特征方程例，写出次态的状态方程，在找输出端写出输出方程。  
3. 列表，横纵分别有触发器现态和输入值，结果是触发器次态和输出值。  
4. 画圈圈，把触发器的变化过程用圈圈画出来，箭头写上输入值和输出值。  
5. 总结。  

**注意**，Moore型的因为次态和输入无关，所以只列输出的表的顺序即可，Mealy型的因为和输入有关所以要建和输入有关的表，注意没有排列到的状态要单独加上，类似于：  
![](l.png)
整个例如Moore型的例题：  
![](m.png)
![](n.png)

## 同步时序逻辑电路的设计
### 设计同步时序逻辑电路的过程
1. 根据实际要求进行逻辑抽象，得出电路的原始状态转换图和转换表。   
2. 状态化简，求最简状态化简表。  
3. 状态编码。第一步. 确定触发器的数目n 第二步. 给每个电路状态分配一组二进制代码，称为状态编码。  
4. 选定触发器类型，求出电路的状态方程。根据状态转换图(或状态转换表)和选定的状态编码、触发器的类型，就可写出电路的状态方程、驱动方程和输出方程。  
5. 根据方程式画出逻辑电路图。  
6. 检查自启动，解决办法：一、通过预置数。二、修改逻辑设计。  

整体步骤如图所示：  
![](o.png)

### 建立原始状态转换图和转换表
![](p.png)

### 完全确定原始状态表化简
状态表化简的原则（若状态表中的任意两个状态Si和Sj，同时满足下列两个条件，则他们可以合并成一个状态）：  
1. 在所有可能的现输入下，两个（或多个）状态相应的现输出分别相同。
2. 在所有可能的现输入下，次态分别为下列情况之一：  
	a. 两个次态完全相同  
	b. 两个次态为状态对循环的一个状态对  
	c. 两个次态为其现态本身或交错  
	d. 两个次态的某一后序状态可以合并  
  
上述的第一个条件是状态合并的必要条件，该条件不满足就无需再考虑第二个条件。  
  
根据状态表化简的原则，利用下列判别方法造出状态表中全部的出状态并对进行分类合并。 
1. 等效状态和等效类  
**等效状态**—满足上述合并条件的两个状态如Si和Sj称为等效状态，或称等效状态对，记为{Si, Sj}。  
**等效状态的传递性**——若状态Si和Sj等效,状态Sj和Sm等效，则状态Si必和Sm等效,称为等效状态的传递性，记为{Si,Sj}{Sj,Sm}→{Si,Sm}   
  
**等效类**——彼此等效状态的集合。
**最大等效类**——若一个等效类不包含在任何其它等效类之中，则称它为最大等效类。这里说的最大，并不是指包含的状态最多，而是指他的**独立性**！。  

显然，状态表的化简的根本任务在于从原始状态表中找出最大等效类，并用一个状态代替。例如：  
![](q.png)  

2. 用隐含表法化简  
隐含表是一个斜边为阶梯型的直角三角形网络。及横向和纵向格数相同，格数为原始状态表的状态数减一。  
然后顺序比较，往表格里填东西。依次比较，若两个状态不是等效对就画X，如果两个状态是等效对则画√，若不确定的则写出下一组状态对，如表：  
![](r.png)
例如CF对完全相同则画✅，又例如AD输出Z都不一样则画叉。还有比如AB两个，输出一样，但是X=0时的次态不同，则无法确定则将CF写入，X=1时因为是两个交换对所以是满足的条件，不用将其写入。最后列出下表：  
![](s.png)	
根据等效关系的传递性，对等效状态对 {A,B}、{A,E}、{B,E}构成等效类{A,B,E}。 等效状态对{C,F}也是等效类。由于等效类 {A,B,E}和{C,F}互不包含在对方的等效类中， 所以，等效类{A,B,E}和{C,F}都是最大等效类。而状态G和D不和任何其它状态等效，因此,它们本身也是一个最大等效类,分别记作{G}和{D}。因此最大等效集合`{A,B,E}，{C,F}，{D}，{G}`  

建立最简状态表。最大等效类集合必须覆盖原始状态表的全部状态。原始状态表中每一个状态只能属于一个最大等效类。这样，每个最大等效类可用一个状态代替。即:`a={ABE} b={CF} c={D} d={G}`由此可得最简状态表：  
![](t.png)


### 不完全确定状态表的化简
这种电路的 状态表包含着不确定的次态或输出，所以，是一种不完全确定电路。并不是任何输出序列都是有效的。不完全确定状态表的化简是基于相容状态的，再利用任意项可使状态表 化的更简。  
**相容状态**——再不完全确定表中，假设S1和S2为初始状态，如果对于所有的有效输入序列从状态S1和S2除法他们相应的输出序列（除不确定的那些之外）是完全相同的，那么状态S1和S2是相容的，或者说S1和S2是相容对，记作（S1，S2）  
**相容状态的条件**——在所有可能输入条件下，两个状态对应的输出相同，或者其中一个（或两个）输出为任意值；并且它们的次态相同、交错、循环、相容，或者其中一个（或两个）为任意状态，那么这两个状态是相容的。  
**相容类**——由彼此相容的状态构成的集合，处于同一相容类 中的所有状态之间都是两两相容的。  
**非传递性**——状态等效具有传递性，而**状态相容不具有传递性**。 因此，若要求(S1, S2，S3)相容，则必须(S1,S2)， (S2,S3)，(S1,S3)都是相容对。也就是说，相容类中所有状态之间都分别是两两相容的。   
**最大相容类**——若一个相容类不是任何其他相容类的子集，则该相容类称为最大相容类。     
例题：  
![](u.png)  
表中由于部分状态的次态和输出无法确定，所以是不完全确定状态表。  
1. 做隐含表并比较，如图    
![](v.png)  
2.在相容状态对中找最大相容类  
![](w.png)  
3. 确定原始状态表的最小闭合覆盖集  
4. **选择一个**同时满足*覆盖、闭合和最小*三个条件的**相容类集合**，将每个相容类用一个新状态来代替，以得到一个新的状态表。  

**覆盖**——指相容类集合中包含了原始状态表的全部状态。即原始状态表中任何一个状态至少包含在相容类集合中的一个相容类(包括最大相容类)中，而不能遗漏。   
**闭合**——指一个相容类集合中,任一相容类的所有隐含条件都必须属于该集合中某一个相容类(包括最大相容类)。  
**最小**——是指满足覆盖和闭合的相容类数目最少。不完全状态表的简化，就是寻找一个最小闭合覆盖  
为了反应闭合和覆盖这两个性质，建立闭合覆盖表：  
![](x.png)  
在表的左边自上而下列出所选相容类，表的中间覆盖部分自左到右列出全部状态，表的右边闭合部分列出各相容类在输入各种取值组合下的次态组合。必须指出，这里所说的相容类包括最大相容类和它们的子类。  
找到了覆盖闭合最小之后，就可以画出最简状态表：  
![](y.png)













